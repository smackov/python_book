<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Строки - My Docs</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Welcome to MkDocs</a>
                            </li>
                            <li class="navitem">
                                <a href="../../visualization/" class="nav-link">Visualization</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Jsbook <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Строки</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../../visualization/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#_1" class="nav-link">Строки</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">Кавычки</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_3" class="nav-link">Строки неизменяемы</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_4" class="nav-link">Изменение регистра</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_5" class="nav-link">Поиск подстроки</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">Получение подстроки</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_9" class="nav-link">Итого</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">Строки</h1>
<p>В JavaScript любые текстовые данные являются строками. Не существует отдельного типа "символ", который есть в ряде других языков.</p>
<p>Внутренний формат для строк — всегда <a href="https://ru.wikipedia.org/wiki/UTF-16">UTF-16</a>, вне зависимости от кодировки страницы.</p>
<h2 id="_2">Кавычки</h2>
<p>В JavaScript есть разные типы кавычек.</p>
<p>Строку можно создать с помощью одинарных, двойных либо обратных кавычек:</p>
<pre><code class="language-js">let single = 'single-quoted';
let double = &quot;double-quoted&quot;;

let backticks = `backticks`;
</code></pre>
<p>Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в <code>${…}</code>:</p>
<p>```js run
function sum(a, b) {
  return a + b;
}</p>
<p>alert(<code>1 + 2 = ${sum(1, 2)}.</code>); // 1 + 2 = 3.</p>
<pre><code>
Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

```js run
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
</code></pre>
<p>Выглядит вполне естественно, не правда ли? Что тут такого? Но если попытаться использовать точно так же одинарные или двойные кавычки, то будет ошибка:</p>
<p>```js run
let guestList = "Guests: // Error: Unexpected token ILLEGAL
  * John";</p>
<pre><code>
Одинарные и двойные кавычки в языке с незапамятных времён: тогда потребность в многострочных строках не учитывалась. Что касается обратных кавычек, они появились существенно позже, и поэтому они гибче.

Обратные кавычки также позволяют задавать &quot;шаблонную функцию&quot; перед первой обратной кавычкой. Используемый синтаксис: &lt;code&gt;func&amp;#96;string&amp;#96;&lt;/code&gt;. Автоматически вызываемая функция `func` получает строку и встроенные в неё выражения и может их обработать. Подробнее об этом можно прочитать в [документации](mdn:/JavaScript/Reference/Template_literals#Tagged_templates). Если перед строкой есть выражение, то шаблонная строка называется &quot;теговым шаблоном&quot;. Это позволяет использовать свою шаблонизацию для строк, но на практике теговые шаблоны применяются редко.

## Спецсимволы

Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый &quot;символ перевода строки&quot;, который записывается как `\n`:

```js run
let guestList = &quot;Guests:\n * John\n * Pete\n * Mary&quot;;

alert(guestList); // список гостей, состоящий из нескольких строк
</code></pre>
<p>В частности, эти две строки эквивалентны, просто записаны по-разному:</p>
<p>```js run
// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";</p>
<p>// многострочная строка, созданная с использованием обратных кавычек
let str2 = <code>Hello
World</code>;</p>
<p>alert(str1 == str2); // true</p>
<pre><code>
Есть и другие, реже используемые спецсимволы. Вот список:

| Символ | Описание |
|-----------|-------------|
|`\n`|Перевод строки|
|`\r`|Возврат каретки: самостоятельно не используется. В текстовых файлах Windows для перевода строки используется комбинация символов `\r\n`. |
|`\'`, `\&quot;`|Кавычки|
|`\\`|Обратный слеш|
|`\t`|Знак табуляции|
|`\b`, `\f`, `\v`| Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются. |
|`\xXX`|Символ с шестнадцатеричным юникодным кодом `XX`, например, `'\x7A'` — то же самое, что `'z'`.|
|`\uXXXX`|Символ в кодировке UTF-16 с шестнадцатеричным кодом `XXXX`, например, `\u00A9` — юникодное представление знака копирайта, `©`. Код должен состоять ровно из 4 шестнадцатеричных цифр. |
|`\u{X…XXXXXX}` (от 1 до 6 шестнадцатеричных цифр)|Символ в кодировке UTF-32 с шестнадцатеричным кодом от U+0000 до U+10FFFF. Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом. |

Примеры с Юникодом:

```js run
// ©
alert( &quot;\u00A9&quot; );

// Длинные юникодные коды
// 佫, редкий китайский иероглиф
alert( &quot;\u{20331}&quot; );
// 😍, лицо с улыбкой и глазами в форме сердец
alert( &quot;\u{1F60D}&quot; );
</code></pre>
<p>Все спецсимволы начинаются с обратного слеша, <code>\</code> — так называемого "символа экранирования".</p>
<p>Он также используется, если необходимо вставить в строку кавычку.</p>
<p>К примеру:</p>
<p>```js run
alert( 'I<em>!</em>\'<em>/!</em>m the Walrus!' ); // <em>!</em>I'm<em>/!</em> the Walrus!</p>
<pre><code>
Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — `\'` — иначе она бы обозначала окончание строки.

Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка. Так что мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки:

```js run
alert( `I'm the Walrus!` ); // I'm the Walrus!
</code></pre>
<p>Заметим, что обратный слеш <code>\</code> служит лишь для корректного прочтения строки интерпретатором, но он не записывается в строку после её прочтения. Когда строка сохраняется в оперативную память, в неё не добавляется символ <code>\</code>. Вы можете явно видеть это в выводах <code>alert</code> в примерах выше.</p>
<p>Но что, если нам надо добавить в строку собственно сам обратный слеш <code>\</code>?</p>
<p>Это можно сделать, добавив перед ним… ещё один обратный слеш!</p>
<p><code>``js run
alert(</code>The backslash: \` ); // The backslash: \</p>
<pre><code>
## Длина строки

Свойство `length` содержит длину строки:

```js run
alert( `My\n`.length ); // 3
</code></pre>
<p>Обратите внимание, <code>\n</code> — это один спецсимвол, поэтому тут всё правильно: длина строки <code>3</code>.</p>
<p><code>``warn header="</code>length<code>— это свойство"
Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут</code>str.length()<code>вместо</code>str.length`. Это не работает.</p>
<p>Так как <code>str.length</code> — это числовое свойство, а не функция, добавлять скобки не нужно.</p>
<pre><code>
## Доступ к символам

Получить символ, который занимает позицию `pos`, можно с помощью квадратных скобок: `[pos]`. Также можно использовать метод `charAt`: [str.charAt(pos)](mdn:js/String/charAt). Первый символ занимает нулевую позицию:

```js run
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
</code></pre>
<p>Квадратные скобки — современный способ получить символ, в то время как <code>charAt</code> существует в основном по историческим причинам.</p>
<p>Разница только в том, что если символ с такой позицией отсутствует, тогда <code>[]</code> вернёт <code>undefined</code>, а <code>charAt</code> — пустую строку:</p>
<p><code>``js run
let str =</code>Hello`;</p>
<p>alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (пустая строка)</p>
<pre><code>
Также можно перебрать строку посимвольно, используя `for..of`:

```js run
for (let char of &quot;Hello&quot;) {
  alert(char); // H,e,l,l,o (char — сначала &quot;H&quot;, потом &quot;e&quot;, потом &quot;l&quot; и т. д.)
}
</code></pre>
<h2 id="_3">Строки неизменяемы</h2>
<p>Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.</p>
<p>Давайте попробуем так сделать, и убедимся, что это не работает:</p>
<p>```js run
let str = 'Hi';</p>
<p>str[0] = 'h'; // ошибка
alert( str[0] ); // не работает</p>
<pre><code>
Можно создать новую строку и записать её в ту же самую переменную вместо старой.

Например:

```js run
let str = 'Hi';

str = 'h' + str[1]; // заменяем строку

alert( str ); // hi
</code></pre>
<p>В последующих разделах мы увидим больше примеров.</p>
<h2 id="_4">Изменение регистра</h2>
<p>Методы <a href="mdn:js/String/toLowerCase">toLowerCase()</a> и <a href="mdn:js/String/toUpperCase">toUpperCase()</a> меняют регистр символов:</p>
<p>```js run
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface</p>
<pre><code>
Если мы захотим перевести в нижний регистр какой-то конкретный символ:

```js
alert( 'Interface'[0].toLowerCase() ); // 'i'
</code></pre>
<h2 id="_5">Поиск подстроки</h2>
<p>Существует несколько способов поиска подстроки.</p>
<h3 id="strindexof">str.indexOf</h3>
<p>Первый метод — <a href="mdn:js/String/indexOf">str.indexOf(substr, pos)</a>.</p>
<p>Он ищет подстроку <code>substr</code> в строке <code>str</code>, начиная с позиции <code>pos</code>, и возвращает позицию, на которой располагается совпадение, либо <code>-1</code> при отсутствии совпадений.</p>
<p>Например:</p>
<p>```js run
let str = 'Widget with id';</p>
<p>alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру</p>
<p>alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)</p>
<pre><code>
Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение `&quot;id&quot;` — на позиции `1`. Для того, чтобы найти следующее, начнём поиск с позиции `2`:

```js run
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
</code></pre>
<p>Чтобы найти все вхождения подстроки, нужно запустить <code>indexOf</code> в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:</p>
<p>```js run
let str = 'Ослик Иа-Иа посмотрел на виадук';</p>
<p>let target = 'Иа'; // цель поиска</p>
<p>let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;</p>
<p>alert( <code>Найдено тут: ${foundPos}</code> );
  pos = foundPos + 1; // продолжаем со следующей позиции
}</p>
<pre><code>
Тот же алгоритм можно записать и короче:

```js run
let str = &quot;Ослик Иа-Иа посмотрел на виадук&quot;;
let target = &quot;Иа&quot;;

*!*
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
*/!*
</code></pre>
<p><code>``smart header="</code>str.lastIndexOf(substr, position)`"
Также есть похожий метод <a href="mdn:js/String/lastIndexOf">str.lastIndexOf(substr, position)</a>, который ищет с конца строки к её началу.</p>
<p>Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до (включительно) определённой позиции.</p>
<pre><code>
При проверке `indexOf` в условии `if` есть небольшое неудобство. Такое условие не будет работать:

```js run
let str = &quot;Widget with id&quot;;

if (str.indexOf(&quot;Widget&quot;)) {
    alert(&quot;Совпадение есть&quot;); // не работает
}
</code></pre>
<p>Мы ищем подстроку <code>"Widget"</code>, и она здесь есть, прямо на позиции <code>0</code>. Но <code>alert</code> не показывается, т. к. <code>str.indexOf("Widget")</code> возвращает <code>0</code>, и <code>if</code> решает, что тест не пройден.</p>
<p>Поэтому надо делать проверку на <code>-1</code>:</p>
<p>```js run
let str = "Widget with id";</p>
<p><em>!</em>
if (str.indexOf("Widget") != -1) {
<em>/!</em>
    alert("Совпадение есть"); // теперь работает
}</p>
<pre><code>
#### Трюк с побитовым НЕ
Существует старый трюк с использованием [побитового оператора НЕ](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#.7E_.28Bitwise_NOT.29) — `~`. Он преобразует число в 32-разрядное целое со знаком (signed 32-bit integer). Дробная часть, в случае, если она присутствует, отбрасывается. Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение `~n` равно `-(n+1)`.

В частности:

```js run
alert( ~2 ); // -3, то же, что -(2+1)
alert( ~1 ); // -2, то же, что -(1+1)
alert( ~0 ); // -1, то же, что -(0+1)
*!*
alert( ~-1 ); // 0, то же, что -(-1+1)
*/!*
</code></pre>
<p>Таким образом, <code>~n</code> равняется 0 только при <code>n == -1</code> (для любого <code>n</code>, входящего в 32-разрядные целые числа со знаком).</p>
<p>Соответственно, прохождение проверки <code>if ( ~str.indexOf("…") )</code> означает, что результат <code>indexOf</code> отличен от <code>-1</code>, совпадение есть.</p>
<p>Это иногда применяют, чтобы сделать проверку <code>indexOf</code> компактнее:</p>
<p>```js run
let str = "Widget";</p>
<p>if (~str.indexOf("Widget")) {
  alert( 'Совпадение есть' ); // работает
}</p>
<pre><code>
Обычно использовать возможности языка каким-либо неочевидным образом не рекомендуется, но этот трюк широко используется в старом коде, поэтому его важно понимать.

Просто запомните: `if (~str.indexOf(…))` означает &quot;если найдено&quot;.

Впрочем, если быть точнее, из-за того, что большие числа обрезаются до 32 битов оператором `~`, существуют другие числа, для которых результат тоже будет `0`, самое маленькое из которых — `~4294967295=0`. Поэтому такая проверка будет правильно работать только для строк меньшей длины.

На данный момент такой трюк можно встретить только в старом коде, потому что в новом он просто не нужен: есть метод `.includes` (см. ниже).

### includes, startsWith, endsWith

Более современный метод [str.includes(substr, pos)](mdn:js/String/includes) возвращает `true`, если в строке `str` есть подстрока `substr`, либо `false`, если нет.

Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

```js run
alert( &quot;Widget with id&quot;.includes(&quot;Widget&quot;) ); // true

alert( &quot;Hello&quot;.includes(&quot;Bye&quot;) ); // false
</code></pre>
<p>Необязательный второй аргумент <code>str.includes</code> позволяет начать поиск с определённой позиции:</p>
<p>```js run
alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3</p>
<pre><code>
Методы [str.startsWith](mdn:js/String/startsWith) и [str.endsWith](mdn:js/String/endsWith) проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

```js run
alert( &quot;Widget&quot;.startsWith(&quot;Wid&quot;) ); // true, &quot;Wid&quot; — начало &quot;Widget&quot;
alert( &quot;Widget&quot;.endsWith(&quot;get&quot;) ); // true, &quot;get&quot; — окончание &quot;Widget&quot;
</code></pre>
<h2 id="_6">Получение подстроки</h2>
<p>В JavaScript есть 3 метода для получения подстроки: <code>substring</code>, <code>substr</code> и <code>slice</code>.</p>
<p><code>str.slice(start [, end])</code>
: Возвращает часть строки от <code>start</code> до (не включая) <code>end</code>.</p>
<pre><code>Например:

```js run
let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
```

Если аргумент `end` отсутствует, `slice` возвращает символы до конца строки:

```js run
let str = "st*!*ringify*/!*";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
```

Также для `start/end` можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов *с конца строки*:

```js run
let str = "strin*!*gif*/!*y";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
```
</code></pre>
<p><code>str.substring(start [, end])</code>
: Возвращает часть строки <em>между</em> <code>start</code> и <code>end</code>.</p>
<pre><code>Это — почти то же, что и `slice`, но можно задавать `start` больше `end`.

Например:

```js run
let str = "st*!*ring*/!*ify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)

```

Отрицательные значения `substring`, в отличие от `slice`, не поддерживает, они интерпретируются как `0`.
</code></pre>
<p><code>str.substr(start [, length])</code>
: Возвращает часть строки от <code>start</code> длины <code>length</code>.</p>
<pre><code>В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

```js run
let str = "st*!*ring*/!*ify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
```

Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

```js run
let str = "strin*!*gi*/!*fy";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );
```
</code></pre>
<p>Давайте подытожим, как работают эти методы, чтобы не запутаться:</p>
<table>
<thead>
<tr>
<th>метод</th>
<th>выбирает…</th>
<th>отрицательные значения</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>slice(start, end)</code></td>
<td>от <code>start</code> до <code>end</code> (не включая <code>end</code>)</td>
<td>можно передавать отрицательные значения</td>
</tr>
<tr>
<td><code>substring(start, end)</code></td>
<td>между <code>start</code> и <code>end</code></td>
<td>отрицательные значения равнозначны <code>0</code></td>
</tr>
<tr>
<td><code>substr(start, length)</code></td>
<td><code>length</code> символов, начиная от <code>start</code></td>
<td>значение <code>start</code> может быть отрицательным</td>
</tr>
</tbody>
</table>
<p><code>``smart header="Какой метод выбрать?"
Все эти методы эффективно выполняют задачу. Формально у метода</code>substr` есть небольшой недостаток: он описан не в собственно спецификации JavaScript, а в приложении к ней — Annex B. Это приложение описывает возможности языка для использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом окружении, отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.</p>
<p>Из двух других вариантов, <code>slice</code> более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его.</p>
<pre><code>
## Сравнение строк

Как мы знаем из главы &lt;info:comparison&gt;, строки сравниваются посимвольно в алфавитном порядке.

Тем не менее, есть некоторые нюансы.

1. Строчные буквы больше заглавных:

    ```js run
    alert( 'a' &gt; 'Z' ); // true
    ```

2. Буквы, имеющие диакритические знаки, идут &quot;не по порядку&quot;:

    ```js run
    alert( 'Österreich' &gt; 'Zealand' ); // true
    ```

    Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, что `Zealand` будет после `Österreich` в списке.

Чтобы разобраться, что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.

Строки кодируются в [UTF-16](https://ru.wikipedia.org/wiki/UTF-16). Таким образом, у любого символа есть соответствующий код. Есть специальные методы, позволяющие получить символ по его коду и наоборот.

`str.codePointAt(pos)`
: Возвращает код для символа, находящегося на позиции `pos`:

    ```js run
    // одна и та же буква в нижнем и верхнем регистре
    // будет иметь разные коды
    alert( &quot;z&quot;.codePointAt(0) ); // 122
    alert( &quot;Z&quot;.codePointAt(0) ); // 90
    ```

`String.fromCodePoint(code)`
: Создаёт символ по его коду `code`

    ```js run
    alert( String.fromCodePoint(90) ); // Z
    ```

    Также можно добавлять юникодные символы по их кодам, используя `\u` с шестнадцатеричным кодом символа:

    ```js run
    // 90 — 5a в шестнадцатеричной системе счисления
    alert( '\u005a' ); // Z
    ```

Давайте сделаем строку, содержащую символы с кодами от `65` до `220` — это латиница и ещё некоторые распространённые символы:

```js run
let str = '';

for (let i = 65; i &lt;= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
</code></pre>
<p>Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и <code>Ö</code> ближе к концу вывода.</p>
<p>Теперь очевидно, почему <code>a &gt; Z</code>.</p>
<p>Символы сравниваются по их кодам. Больший код — больший символ. Код <code>a</code> (97) больше кода <code>Z</code> (90).</p>
<ul>
<li>Все строчные буквы идут после заглавных, так как их коды больше.</li>
<li>Некоторые буквы, такие как <code>Ö</code>, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от <code>a</code> до <code>z</code>.</li>
</ul>
<h3 id="_7">Правильное сравнение</h3>
<p>"Правильный" алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные алфавиты.</p>
<p>Поэтому браузеру нужно знать, какой язык использовать для сравнения.</p>
<p>К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека <a href="https://github.com/andyearnshaw/Intl.js/">Intl.JS</a>) поддерживают стандарт <a href="http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf">ECMA 402</a>, обеспечивающий правильное сравнение строк на разных языках с учётом их правил.</p>
<p>Для этого есть соответствующий метод.</p>
<p>Вызов <a href="mdn:js/String/localeCompare">str.localeCompare(str2)</a> возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:</p>
<ul>
<li>Отрицательное число, если <code>str</code> меньше <code>str2</code>.</li>
<li>Положительное число, если <code>str</code> больше <code>str2</code>.</li>
<li><code>0</code>, если строки равны.</li>
</ul>
<p>Например:</p>
<p>```js run
alert( 'Österreich'.localeCompare('Zealand') ); // -1</p>
<pre><code>
У этого метода есть два дополнительных аргумента, которые указаны в [документации](mdn:js/String/localeCompare). Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между `&quot;a&quot;` и `&quot;á&quot;`.

## Как всё устроено, Юникод

```warn header=&quot;Глубокое погружение в тему&quot;
Этот раздел более подробно описывает, как устроены строки. Такие знания пригодятся, если вы намерены работать с эмодзи, редкими математическими символами, иероглифами, либо с ещё какими-то редкими символами.

Если вы не планируете их поддерживать, эту секцию можно пропустить.
</code></pre>
<h3 id="_8">Суррогатные пары</h3>
<p>Многие символы возможно записать одним 16-битным словом: это и буквы большинства европейских языков, и числа, и даже многие иероглифы.</p>
<p>Но 16 битов — это 65536 комбинаций, так что на все символы этого, разумеется, не хватит. Поэтому редкие символы записываются двумя 16-битными словами — это также называется "суррогатная пара".</p>
<p>Длина таких строк — <code>2</code>:</p>
<p>```js run
alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X
alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY
alert( '𩷶'.length ); // 2, редкий китайский иероглиф</p>
<pre><code>
Обратите внимание, суррогатные пары не существовали, когда был создан JavaScript, поэтому язык не обрабатывает их адекватно!

Ведь в каждой из этих строк только один символ, а `length` показывает длину `2`.

`String.fromCodePoint` и `str.codePointAt` — два редких метода, правильно работающие с суррогатными парами, но они и появились в языке недавно. До них были только [String.fromCharCode](mdn:js/String/fromCharCode) и [str.charCodeAt](mdn:js/String/charCodeAt). Эти методы, вообще, делают то же самое, что `fromCodePoint/codePointAt`, но не работают с суррогатными парами.

Получить символ, представленный суррогатной парой, может быть не так просто, потому что суррогатная пара интерпретируется как два символа:

```js run
alert( '𝒳'[0] ); // странные символы…
alert( '𝒳'[1] ); // …части суррогатной пары
</code></pre>
<p>Части суррогатной пары не имеют смысла сами по себе, так что вызовы <code>alert</code> в этом примере покажут лишь мусор.</p>
<p>Технически, суррогатные пары возможно обнаружить по их кодам: если код символа находится в диапазоне <code>0xd800..0xdbff</code>, то это — первая часть суррогатной пары. Следующий символ — вторая часть — имеет код в диапазоне <code>0xdc00..0xdfff</code>. Эти два диапазона выделены исключительно для суррогатных пар по стандарту.</p>
<p>В данном случае:</p>
<p>```js run
// charCodeAt не поддерживает суррогатные пары, поэтому возвращает код для их частей</p>
<p>alert( '𝒳'.charCodeAt(0).toString(16) ); // d835, между 0xd800 и 0xdbff
alert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, между 0xdc00 и 0xdfff</p>
<pre><code>
Дальше в главе &lt;info:iterable&gt; будут ещё способы работы с суррогатными парами. Для этого есть и специальные библиотеки, но нет достаточно широко известной, чтобы предложить её здесь.

### Диакритические знаки и нормализация

Во многих языках есть символы, состоящие из некоторого основного символа со знаком сверху или снизу.

Например, буква `a` — это основа для `àáâäãåā`. Наиболее используемые составные символы имеют свой собственный код в таблице UTF-16. Но не все, в силу большого количества комбинаций.

Чтобы поддерживать любые комбинации, UTF-16 позволяет использовать несколько юникодных символов: основной и дальше один или несколько особых символов-знаков.

Например, если после `S` добавить специальный символ &quot;точка сверху&quot; (код `\u0307`), отобразится Ṡ.

```js run
alert( 'S\u0307' ); // Ṡ
</code></pre>
<p>Если надо добавить сверху (или снизу) ещё один знак — без проблем, просто добавляем соответствующий символ.</p>
<p>Например, если добавить символ "точка снизу" (код <code>\u0323</code>), отобразится S с точками сверху и снизу: <code>Ṩ</code>.</p>
<p>Добавляем два символа:</p>
<p>```js run
alert( 'S\u0307\u0323' ); // Ṩ</p>
<pre><code>
Это даёт большую гибкость, но из-за того, что порядок дополнительных символов может быть различным, мы получаем проблему сравнения символов: можно представить по-разному символы, которые ничем визуально не отличаются.

Например:

```js run
let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)
</code></pre>
<p>Для решения этой проблемы есть алгоритм "юникодной нормализации", приводящий каждую строку к единому "нормальному" виду.</p>
<p>Его реализует метод <a href="mdn:js/String/normalize">str.normalize()</a>.</p>
<p>```js run
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true</p>
<pre><code>
Забавно, но в нашем случае `normalize()` &quot;схлопывает&quot; последовательность из трёх символов в один: `\u1e68` — S с двумя точками.

```js run
alert( &quot;S\u0307\u0323&quot;.normalize().length ); // 1

alert( &quot;S\u0307\u0323&quot;.normalize() == &quot;\u1e68&quot; ); // true
</code></pre>
<p>Разумеется, так происходит не всегда. Просто Ṩ — это достаточно часто используемый символ, поэтому создатели UTF-16 включили его в основную таблицу и присвоили ему код.</p>
<p>Подробнее о правилах нормализации и составлении символов можно прочитать в дополнении к стандарту Юникод: <a href="http://www.unicode.org/reports/tr15/">Unicode Normalization Forms</a>. Для большинства практических целей информации из этого раздела достаточно.</p>
<h2 id="_9">Итого</h2>
<ul>
<li>Есть три типа кавычек. Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения <code>${…}</code>.</li>
<li>Строки в JavaScript кодируются в UTF-16.</li>
<li>Есть специальные символы, такие как <code>\n</code>, и можно добавить символ по его юникодному коду, используя <code>\u…</code>.</li>
<li>Для получения символа используйте <code>[]</code>.</li>
<li>Для получения подстроки используйте <code>slice</code> или <code>substring</code>.</li>
<li>Для того, чтобы перевести строку в нижний или верхний регистр, используйте <code>toLowerCase/toUpperCase</code>.</li>
<li>Для поиска подстроки используйте <code>indexOf</code> или <code>includes/startsWith/endsWith</code>, когда надо только проверить, есть ли вхождение.</li>
<li>Чтобы сравнить строки с учётом правил языка, используйте <code>localeCompare</code>.</li>
</ul>
<p>Строки также имеют ещё кое-какие полезные методы:</p>
<ul>
<li><code>str.trim()</code> — убирает пробелы в начале и конце строки.</li>
<li><code>str.repeat(n)</code> — повторяет строку <code>n</code> раз.</li>
<li>…и другие, которые вы можете найти в <a href="mdn:js/String">справочнике</a>.</li>
</ul>
<p>Также есть методы для поиска и замены с использованием регулярных выражений. Но это отдельная большая тема, поэтому ей посвящена отдельная глава учебника <info:regular-expressions>.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
